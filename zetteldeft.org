#+title: Zetteldeft
#+author: EFLS
#+date: July 2018
:headers:
# By default, each block of code should tangle & evaluate silently
#+PROPERTY: header-args:emacs-lisp :results silent :tangle zetteldeft.el
:end:
:statuses:
# Different statuses
#+TODO: FIX(f) NEW(n) DEV(o) | DONE(d)
# FIX: Fix needed
# NEW: New feature, awaiting implementation
# DEV: In development
:end:
:export:
#+OPTIONS: date:nil toc:nil H:4
#+EXPORT_FILE_NAME: ./docs/index
# CSS
#+HTML_HEAD: <link rel='stylesheet' href='style.css' type='text/css'/>
# PDF
#+LATEX_HEADER: \usepackage[]{efls-doc}
:end:

* Introduction                                 :ignore:

This document contains all the source code to a set of functions for =emacs= which aim to extend the =deft= package and turn it into a (very very) basic Zettelkasten note-taking system.

Check out the github [[https://github.com/EFLS/zetteldeft][repository]] to get the source.
Read on for an introduction and some documentation.

Latest additions:
 - *4 Nov*: =zd-all-tags= and =zd-tag-buffer= find all tags
 - *24 Oct*: =zd-avy-file-search-other-window= follows an ID link and opens file in other window
 - *21 Oct*: =zetteldeft= is now a package.
 - *10 Oct*: Insert contents of files with given search term with =zd-org-search-insert=.
 - *24 Sep*: Count the total number of words in your zetteldeft with =zd-count-words=.
 - *18 July*: Include a list of links with =zd-insert-list-links=, or a list of files with =zd-org-search-include=.

# Table of Contents
#+TOC: headlines 2

* What?
** A Zettelkasten system for =emacs= based on =deft=

This is my feeble attempt at recreating a Zettelkasten environment by extending the excellent =deft= package in =emacs=.[fn:deft]
I call it *zetteldeft*.

It is inspired by the /The Archive/ app. For this and more on the Zettelkasten way of taking notes, see [[https://zettelkasten.de][zettelkasten.de]]. They have a forum for discussion on both software and the specifics of the Zettelkasten philosophy.

The code that follows is created and maintained for my personal use, shared here in hope that it can benefit others as well.
I'd be happy to learn how you use it and expand upon it.

It is very much WIP and I'm fairly new to =elisp=, so it might contain some stupid code.

Anyway, here we go.

[fn:deft] For those not yet familiar: *deft* is a note manager within =emacs=, for easily searching and retrieving plain text notes.
It is inspired by the popular Notational Velocity.
Check out [[https://jblevins.org/projects/deft/][jblevins.org/projects/deft/]] and [[http://notational.net][notational.net]].

** How to use this source

This package requires:
 - =deft=, obviously
 - =avy= to jump & search

From the github repository, either
 - download the =org-file= and =org-tangle= it yourself. It should contain everything.
 - or download the =zetteldeft.el= file.

Whichever way you go, load up the package by adding the package to your load path and requiring:

#+BEGIN_SRC emacs-lisp :tangle no
(add-to-list 'load-path "~/path/to/folder/"))
(require 'zetteldeft)
#+END_SRC

and you're good to go!
Well, not quite. First you must read on about the basics of =zetteldeft=.

** Basic concepts

*Notes* reside in the =deft-directory=.
Notes are written in =org-mode= syntax (although most functions should work in =markdown= as well).

The filename of a note starts with a unique *id* based on the time and the date, for example: =2018-07-09-2115 This is a note.org=.

This unique id can be used to *link* notes together.
A link is indicated by a =§= character, followed by the id.
For example: =§2018-07-09-2115= should link to the file above.
A link can appear anywhere in the text.

When searching =deft= with the *id* as a filter, you'll find both the original note (with the id in its name) and all the notes that link to this note (with the id in its body). Do so with =zd-search-current-id= and =zd-avy-link-search= respectively

Notes can contain *tags* in plain text: words prepended with a =#=.
This is a tag: =#tag=.
Tags make it easy to retrieve notes. They can appear anywhere in the note, but I'd suggest putting them somewhere at the top.

** Basic actions

Create a note with =zd-new-file= and provide a name.

Insert links to other notes: use =zd-find-file-id-insert= and select a file from the list.
With =zd-find-file-full-title-insert=, you guessed it, the note's title is included as well.
To branch out from a current note and link to a new one, use =zd-new-file-and-link=.

To search for a tag or anything else under cursor, use =zd-search-at-point=.
Combined with the power of =avy= to jump to any character on screen, use these to jump and search in one go: =zd-avy-link-search= and =zd-avy-tag-search=.

To open the note behind a link, use =zd-avy-file-search=.

** An overview

While there are more functions, these should be enough to get you started.
Default keybindings are suggested at the bottom of this document.
Here is an overview.

| Function               | Use                              | Keybinding |
|------------------------+----------------------------------+------------|
| =zd-new-file=            | Create new note and open         | =SPC d n=    |
| =zd-new-file-and-link=   | Create new note and insert =§= id  | =SPC d N=    |
| =zd-find-file-id-insert= | Pick a note and insert its =§= id  | =SPC d i=    |
| =zd-search-at-point=     | Search for thing at point        | =SPC d s=    |
| =zd-avy-file-search=     | Select =§= id and open linked file | =SPC d f=    |
| =zd-avy-link-search=     | Select =§= id and search for it    | =SPC d l=    |
| =zd-avy-tag-search=      | Select =#= tag and search for it   | =SPC d t=    |
| =zd-search-current-id=   | Search for id of current file    | =SPC d c=    |

More details documented below.

* The =zetteldeft= package
** Package setup

In this section:
#+TOC: headlines 2 local

*** Preamble

Some declaration.

#+BEGIN_SRC emacs-lisp
;;; zetteldeft.el --- a simple package                     -*- lexical-binding: t; -*-

;; Copyright (C) 2018  EFLS

;; Author: EFLS <email>
;; Keywords: deft zettelkasten zetteldeft
;; Version: 0.0.1

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Zetteldeft: turn deft into a zettelkasten writing system to create linked notes.

;;; Code:
#+END_SRC

*** Requirements

#+BEGIN_SRC emacs-lisp
(require 'deft)

(unless (package-installed-p 'avy)
  (user-error 'zetteldeft "Avy not installed, required for zd-avy-* functions."))
(require 'avy)
#+END_SRC

*** Customization

For easy but minor customization options.

#+BEGIN_SRC emacs-lisp
(defgroup zetteldeft nil
  "A zettelkasten on top of deft.")
#+END_SRC

** Basic =zetteldeft= functions

In this section:
#+TOC: headlines 2 local

*** Search functions
**** =zd-get-thing-at-point= returns string

Returns the thing at point as string.

Tries to get, in the following order:
 - links between =[[=
 - hashtags: =§=, =#= or =@=
 - words

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-get-thing-at-point ()
"Return the thing at point, which can be a link, tag or word."
  (require 'thingatpt)
  (let* ((link-re "\\[\\[\\([^]]+\\)\\]\\]")
         (htag-re "\\([§#@][[:alnum:]_-]+\\)"))
   (cond
    ((thing-at-point-looking-at link-re)
      (match-string-no-properties 1))
     ((thing-at-point-looking-at htag-re)
      (match-string-no-properties 1))
     (t (thing-at-point 'word t)))))
#+END_SRC

**** =zd-search-at-point= thing at point

Search the thing at point.
Note that calling =zd-search-at-point= on a =§= link includes =§= in the filter string.

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-search-at-point ()
"Search deft with thing-at-point as filter.
Thing can be a double-bracketed link, a hashtag, or a word."
  (interactive)
  (let ((string (zd-get-thing-at-point)))
   (if string
       (zd-search-global string t)
     (user-error "No search term at point"))))
#+END_SRC

**** =zd-search-global= for string

Search with deft for given string.
If there is only one result, that file is opened, unless additional argument is true.

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-search-global (str &optional dntOpn)
"Search deft with STR as filter.
If there is only one result, open that file (unless DNTOPN is true)."
  ;; Sanitize the filter string
  (setq str (replace-regexp-in-string "[[:space:]\n]+" " " str))
  ;; Call deft search on the filter string
  (let ((deft-incremental-search t))
   (deft)
   (deft-filter str t))
  ;; If there is a single match, open the file
  (unless dntOpn
   (when (eq (length deft-current-files) 1)
     (deft-open-file (car deft-current-files)))))
#+END_SRC

**** =zd-search-filename= for string

Deft search on filename.
If there is only one result, open that file.

Incremental search is turned off, and the filter is set to filenames only.

#+BEGIN_SRC emacs-lisp
(defun zd-search-filename (thisStr &optional otherWindow)
"Search for deft files with string THISSTR in filename.
Open if there is only one result (in another window if otherWindow is non-nill)."
  ;; Sanitize the filter string
  (setq thisStr (replace-regexp-in-string "[[:space:]\n]+" " " thisStr))
  ;; Call deft search on the filter string
  (let ((deft-filter-only-filenames t))
   (deft-filter thisStr t))
  ;; If there is a single match, open the file
  (when (eq (length deft-current-files) 1)
    (deft-open-file (car deft-current-files) otherWindow)))
#+END_SRC

**** =zd-search-current-id= searches current id

Deft search on the id of the current file.

Result is not opened automaticaly.

This function is useful to easily see which notes link to the current file.

#+BEGIN_SRC emacs-lisp
(defun zd-search-current-id ()
"Search deft with the id of the current file as filter.
Open if there is only one result."
 (interactive)
 (zd-search-global (zd-id-current-file) t))
#+END_SRC

*** IDs
**** =zd-id-format= for generating ID strings

String format when generating ids.

#+BEGIN_SRC emacs-lisp
(defcustom zd-id-format "%Y-%m-%d-%H%M"
  "Format used when generating zetteldeft IDs.
Be warned: the regexp to find these IDs is set separately."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

While we're at it, lets tell deft to create new files with this new format.
For good measure: I advise creating new notes in the =zetteldeft= system with =zd-new-file= or =zd-new-file-and-link= as defined below.

#+BEGIN_SRC emacs-lisp
(setq deft-new-file-format zd-id-format)
#+END_SRC

Here is the function to generate an ID string in said format.

#+BEGIN_SRC emacs-lisp
(defun zd-generate-id ()
  "Generates an id in `zd-id-format'."
  (format-time-string zd-id-format))
#+END_SRC

**** =zd-id-regex= for finding IDs

The regular expression used to search for zetteldeft IDs.

This dictates that a zetteldeft ID should consist of:
 1. a series of exactly 4 numbers
 2. followed by exactly 3 sets of a dash and two or more numbers

#+BEGIN_SRC emacs-lisp
(defcustom zd-id-regex "[0-9]\\{4\\}\\(-[0-9]\\{2,\\}\\)\\{3\\}"
  "The regex used to search for zetteldeft IDs."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

**** =zd-lift-id= filters the ID from a string

Return the zetteldeft ID from any string.

Searches with a temporary buffer, from the end of the string backwards (hence the =-1= argument), which implies that the last zetteldeft string is returned.

#+BEGIN_SRC emacs-lisp
(defun zd-lift-id (str)
  "Extract the zetteldeft ID from STR with the regular expression stored in `zd-id-regex'."
  (with-temp-buffer
    (insert str)
    (when (re-search-forward zd-id-regex nil t -1)
      (match-string 0))))
#+END_SRC

Or are there better ways than working =with-temp-buffer=?

Here is a little test.

#+BEGIN_SRC emacs-lisp :exports both :tangle no :results replace value
(zd-lift-id "2018-11-09-1934-12 Some text (1989) - testing (2000 p. 12-25)")
#+END_SRC

#+RESULTS:
: 2018-11-09-1934

**** =zd-id-current-file= returns id in filename

Return the ID from the filename the buffer is currently visiting.

Steps:
 1. Get the filename from the buffer
 2. Strip the ID from it.
 3. Result can be empty string when no id is detected in the filename.

#+BEGIN_SRC emacs-lisp
(defun zd-id-current-file ()
"Return the id from the filename the buffer is currently visiting."
 (zd-lift-id (file-name-base (buffer-file-name))))
#+END_SRC

*** Finding & linking files from minibuffer
**** =zd-find-file= opens file from minibuffer

Select file from the deft folder from the minibuffer.

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file (file)
"Open deft file FILE."
 (interactive
  (list (completing-read "Deft find file: "
        (deft-find-all-files-no-prefix))))
 (deft-find-file file))
#+END_SRC

**** =zd-find-file-id-copy= copies file id

Select file from minibuffer and add its link id to kill ring.

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file-id-copy (file)
"Find deft file FILE and add its id to the kill ring."
 (interactive (list
        (completing-read "File to copy id from: "
        (deft-find-all-files-no-prefix))))
  (kill-new (concat "§" (zd-lift-id file))))
#+END_SRC

**** =zd-find-file-id-insert= inserts file id

Select file from minibuffer and insert its link, prepended by =§=.

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file-id-insert (file)
"Find deft file FILE and insert its link id, prepended by §."
 (interactive (list
        (completing-read "File to insert id from: "
        (deft-find-all-files-no-prefix))))
  (insert (concat "§" (zd-lift-id file))))
#+END_SRC

**** =zd-find-file-full-title-insert= inserts full file title

Select file from minibuffer and insert its link, prepended by =§=.

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file-full-title-insert (file)
"Find deft file FILE and insert its link id with title, prepended by §."
 (interactive (list
        (completing-read "File to insert full title from: "
        (deft-find-all-files-no-prefix))))
  (insert (concat "§" (file-name-base file))))
#+END_SRC

*** New file creation
**** =zd-new-file= creates new file

Create new file with filename as =zd-id-format= and a string.

Either provide a name as argument, or enter one in the mini-buffer.
A title is automatically added to the file, unless an additioanl parameter is given.
When =evil= is used, enter the insert state as well.
The full name is added to the kill ring.
Note that the file is only actually created upon save.

#+BEGIN_SRC emacs-lisp
(defun zd-new-file (str &optional empty)
"Create a new deft file. Filename is `zd-id-format' appended by STR. No extension needed.

After creating, the title is inserted in org-mode format (unless EMPTY is true) and the full file name is added to the kill ring."
 (interactive (list (read-string "name: ")))
 (let* ((zdId (zd-generate-id))
        (zdName (concat zdId " " str)))
 (deft-new-file-named zdName)
 (kill-new zdName)
 (unless empty (zd-insert-org-title))
 (when (featurep 'evil) (evil-insert-state))))
#+END_SRC

**** =zd-new-file-and-link= inserts generated id

Generate an id, append a name, and generate a new file based on id and link.

Either provide a name as argument, or enter one in the mini-buffer.

#+BEGIN_SRC emacs-lisp
(defun zd-new-file-and-link (str)
"Inserts generated id with `zd-id-format' appended with STR.
Creates new deft file with id and STR as name."
 (interactive (list (read-string "name: ")))
 (insert "§" (zd-generate-id) " " str)
 (zd-new-file str))
#+END_SRC

*** Functions with =avy=
**** =zd-avy-tag-search=

Use avy to jump to a tag and search for it.

The search term should include the =#= as tag identifier, so it's as easy as jumping to the =#= and running =zd-search-at-point=.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-tag-search ()
"Call on avy to jump and search tags indicated with #."
 (interactive)
 (save-excursion
  (avy-goto-char ?#)
  (zd-search-at-point)))
#+END_SRC

**** =zd-avy-link-search=

Use avy to jump to an id and search for it.

Jumps to the =§= identifier and searches for the thing at point -- excluding the =§= character.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-link-search ()
"Call on avy to jump and search link ids indicated with §.
Opens immediately if there is only one result."
 (interactive)
 (save-excursion
  (avy-goto-char ?§)
  (zd-search-global (zd-lift-id (zd-get-thing-at-point)))))
#+END_SRC

**** =zd-avy-file-search=

Select and follow an ID link to a file.

Use avy to jump to an id and find the corresponding file.
There should be only one result, as the id should be unique.
That file is then opend (in another window if requested).

Jump to a =§= with =avy=, get the thing at point.
If it is non-nil, search it after sanitizing.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-file-search (&optional otherWindow)
"Call on avy to jump to link ids indicated with § and use it to search for filenames.
Open that file (when it is the only search result, and in another window if OTHERWINDOW)."
 (interactive)
 (save-excursion
  (avy-goto-char ?§)
  (zd-search-filename (zd-lift-id (zd-get-thing-at-point)) otherWindow)))
#+END_SRC

For easier access, let's define a function to open in the other window.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-file-search-other-window ()
"Call on avy to jump to link ids indicated with § and use it to search for filenames.
Open that file in other window (when it is the only search result)."
 (interactive)
 (zd-avy-file-search t))
#+END_SRC

*** Utility functions
**** Deft new search

The following function launches deft, clears the filter and enters =evil-insert-state= (when evil is used).

#+BEGIN_SRC emacs-lisp
(defun zd-deft-new-search ()
"Launch deft, clear filter and enter insert state."
 (interactive)
 (deft)
 (deft-filter-clear)
 (when (featurep 'evil) (evil-insert-state)))
#+END_SRC

**** =zd-file-rename= renames visited file

Rename the current file.
Based on the function =deft-rename-file= with only minor changes in the way =old-filename= is set: from current buffer rather than from =deft= search buffer.

Probably requires some more testing.
Anyway, best to use this only when visiting a file in the deft directory.

The function also updates the =#+title:= at the top of the buffer, if any is present.

#+BEGIN_SRC emacs-lisp
(defun zd-file-rename ()
"Rename the current file via the deft function. Use this on files in the deft-directory."
 (interactive)
  (let ((old-filename (buffer-file-name))
        (deft-dir (file-name-as-directory deft-directory))
        new-filename old-name new-name)
    (when old-filename
      (setq old-name (deft-base-filename old-filename))
      (setq new-name (read-string
                      (concat "Rename " old-name " to (without extension): ")
                      old-name))
      (setq new-filename
            (concat deft-dir new-name "." deft-default-extension))
      (rename-file old-filename new-filename)
      (deft-update-visiting-buffers old-filename new-filename)
      (zd-update-title-in-file)
      (deft-refresh))))
#+END_SRC

To update the title of the currently visited file, the following function is used.

#+BEGIN_SRC emacs-lisp
(defun zd-update-title-in-file ()
"Update the #+TITLE in the current file, if present."
  (save-excursion
    (let ((zd-string-after-title ""))
      (goto-char (point-min))
      (when (search-forward "#+title:" nil t)
        (delete-region (line-beginning-position) (line-end-position))
        (zd-insert-org-title)))))
#+END_SRC

**** =zd-insert-org-title= inserts file title in org-mode

Easily insert the title of the current file in =org-mode= syntax, i.e. as a =#+title:= line.

The code gets the base of the buffer file name, takes from it the file title (i.e. strips the link id at the beginning), and inserts the remaining string.

Below the title, an additional template string is inserted automatically.
This string, variable =zd-string-after-title=, can be customized and is empty by default.

#+BEGIN_SRC emacs-lisp
(defun zd-insert-org-title ()
 "Insert filename of current file as org syntax."
 (interactive)
 (insert
   "#+title: "
   (zd-lift-file-title (file-name-base (buffer-file-name)))
   zd-string-after-title))
#+END_SRC

Customize the string to be inserted below the title.
Used when generating a new file.

#+BEGIN_SRC emacs-lisp
(defcustom zd-string-after-title ""
  "String inserted below title when `zd-insert-org-title' is called.
Empty by default.
Don't forget to add `\\n' at the beginning to start a new line."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

**** =zd-count-words= counts total number of words

To count the total number of words, lets loop over all the files and count words in each.
The total is printed in the minibuffer.

#+BEGIN_SRC emacs-lisp
(defun zd-count-words ()
  "Prints total number of words and notes in the minibuffer."
  (interactive)
  (let ((numWords 0))
    (dolist (deftFile deft-all-files)
      (with-temp-buffer
        (insert-file-contents deftFile)
        (setq numWords (+ numWords (count-words (point-min) (point-max))))))
    (message "Your zettelkasten contains %s notes with %s words in total." (length deft-all-files) numWords)))
#+END_SRC

** Gathering tags

One *issue*: when a url uses a =#=, it can be mistaken for a tag.

=zd-all-tags= puts all tags in =zd-tag-list= and returns them.

Use =zd-tag-buffer= to create a buffer with all tags.

*** =zd-all-tags= returns them all

Extracting tags with =zd-extract-tags=.

#+BEGIN_SRC emacs-lisp
(defun zd-all-tags ()
  "Return a list of all the tags found in zetteldeft files."
  (setq zd-tag-list (list))
  (dolist (deftFile deft-all-files)
    (zd-extract-tags deftFile))
  zd-tag-list)
#+END_SRC

*** =zd-tag-buffer= puts all tags in a buffer

The name of the buffer we'll be using:

#+BEGIN_SRC emacs-lisp
(setq zd-tag-buffer-name "*zd-tag-buffer*")
#+END_SRC

And some code to create that buffer.

Move to the =zd-tag-buffer-name=

#+BEGIN_SRC emacs-lisp
(defun zd-tag-buffer ()
  "Switch to the *zd-tag-buffer* and list tags."
  (interactive)
  (switch-to-buffer zd-tag-buffer-name)
  (erase-buffer)
  (dolist (zdTag (zd-all-tags))
    (insert (format "%s \n" zdTag)))
  (unless (eq major-mode 'org-mode) (org-mode))
  (sort-lines nil (point-min) (point-max)))
#+END_SRC

*** Tag extracting functions

Some utility functions to achieve all of this.

**** =zd-tag-format= provides the tag-finding regex

The regular expression used to filter out tags.
Tags start with a =#= or =@= and contain least one or more letters.
Dashes are allowed.

Tags should be positioned either be at the beginning of a new line, or preceded by a space.
This should help filter out hashtags used in URLs.

#+BEGIN_SRC emacs-lisp
(defcustom zd-tag-format "\\(^\\|\s\\)[#@][a-z-]+"
  "Regular expression used to filter out tags."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

**** =zd-extract-tags= from a file

Open a given file in a temporary buffer.
Loop a search for the tag regexp.
When a tag is found, remove any whitespace from it and add it to the =zd-tag-list= if it isn't there already.
Delete the found tag and search again.

#+BEGIN_SRC emacs-lisp
(defun zd-extract-tags (deftFile)
  "Find all tags in DEFTFILE and add them to zd-tag-list"
  (with-temp-buffer
    (insert-file-contents deftFile)
    (while (re-search-forward zd-tag-format nil t)
      (let ((foundTag (replace-regexp-in-string " " "" (match-string 0))))
        ;; Add found tag to zd-tag-list if it isn't there already
        (unless (member foundTag zd-tag-list)
          (push foundTag zd-tag-list)))
      ;; Remove found tag from buffer
      (delete-region (point) (re-search-backward zd-tag-format)))))
#+END_SRC

** Gathering notes

In this section:
#+TOC: headlines 2 local

*** On "gathering notes"

Sometimes you want to easily gather all notes with a certain tag or search term.
Say you want to quickly generate a list of links to all files including the tag =#zetteldeft=.

The following functions do that for you.
There are three of them, each either taking a search term as argument or prompting for one:
 1. =zd-insert-list-links= inserts a simple list of notes which contain the search term, spelling out the full filename for each note (including ID).
 2. =zd-org-search-include= generates =org-mode= syntax to =#+INCLUDE= the files below a header with their title.
 3. =zd-org-search-insert= inserts the contents of all of these notes below their respective titles.

More documentation can be found below.
    
*** List of links
**** =zd-insert-list-links= generates list with tagged files

Creates and inserts a list with links to all files with selected search term.

The code gets a list of files that contain the search string, runs through said list and inserts a link for each entry.

#+BEGIN_SRC emacs-lisp
(defun zd-insert-list-links (zdSrch)
"Inserts at point a list of links to all deft files with a search string ZDSRCH.
When searching for a tag, include # manually in the search."
 (interactive (list (read-string "search string: ")))
 (dolist (zdFile (zd-get-file-list zdSrch))
  (zd-list-entry-file-link zdFile)))
#+END_SRC

**** =zd-list-entry-file-link= includes a file link as list entry

Inserts for given file a link id and title as a list entry.

#+BEGIN_SRC emacs-lisp
(defun zd-list-entry-file-link (zdFile)
"Insert ZDFILE as list entry."
 (insert " - " (concat "§" (file-name-base zdFile)) "\n"))
#+END_SRC

*** Compiling a single =org=
**** Idea and example
***** Including notes with given search term

The following explains what =zd-org-search-include= does, but the concept is more or less the same for =zd-org-search-insert=.

For each of the notes with the provided search term, it inserts a heading, a line with =#+INCLUDE= and the full path to the relevant notes.
This results in a single file that can be easily exported.

The only function meant for use on the users end, is =zd-org-search-include=.

For example,

#+BEGIN_SRC emacs-lisp :tangle no
(zd-org-search-include "#export")
#+END_SRC

inserts necessary code to include all files containing the tag =#export=.
The results would look like the following:

#+BEGIN_SRC org
\* First file title
#+INCLUDE: "/path/to/2018-07-13-2210 First file title.org"

\* File two
#+INCLUDE: "/path/to/2018-07-13-2223 File two.org"
#+END_SRC

All functions are documented below.

***** Semi-automated example

You could, for example, add the following code to a document and execute (or evaluate) it from within =org-mode=.
Add it under a "comment" type heading to prevent it from being exported itself, like so: =* COMMENT Code=.

#+BEGIN_SRC emacs-lisp :tangle no
(let (frst)
  (save-excursion
    ;; Move to next heading
    (outline-next-heading)
    (setq frst (point))
    ;; Delete everything after
    (delete-region frst (point-max))
    ;; Include the files
    (zd-org-search-include "#tag")
    ; Sort these entries alphabetically (set mark to use a region)
;   (goto-char frst) (set-mark (point-max))
;   (org-sort-entries nil ?a)
  ))
#+END_SRC

The code deletes everything after the current header and inserts all notes with =#tag= in them.

In order to also sort the entries alphabetically, uncomment the last two lines.

A final caveat: don't put the file with the above code in you =deft= folder, or it will attempt to include itself (since it has =#tag= in it).

***** Issues & things to note

Before we look at the functions, a note on limitations of the current implementation.

1. *Over-enthousiastic inclusion*
   Sometimes, a tag appears in a file without the need for it to be included.
   For example, a file with a list of all tags will also include the tag one wants.
   In the future, this might be resolved by filtering, for example with http://ergoemacs.org/emacs/elisp_filter_list.html.

2. *Inclusion from second line onwards*
   Currently, the =#+INCLUDE= lines only include from the second line onwards.
   This is a work-around to prevent =#+TITLE= lines from being included (and messing up the title on =org-export=.
   To change this, edit the inserted strings in the =zd-org-include-file= function.

3. *Sorting*
   The files included are unsorted, or rather: sorted as =deft= provides the results.
   Attempts at sorting by title are included in =zd-get-file-list=, but not working properly.
   As a solution, use =org-sort= manually after running =zd-org-search-include=.

**** =zd-org-search-include= generates =#+INCLUDE= syntax

Asks user for a search string and inserts headers and =#+INCLUDE= code for all files with said tag.
When used on =#tag=, make sure to include the =#= manually.

#+BEGIN_SRC emacs-lisp
(defun zd-org-search-include (zdSrch)
"Inserts at point org-mode code to include all files with the selected tag. Include the # manually in the prompt."
 (interactive (list (read-string "tag (include the #): ")))
 (dolist (zdFile (zd-get-file-list zdSrch))
  (zd-org-include-file zdFile)))
#+END_SRC

**** =zd-org-search-insert= generates titles & file content

Very similar to the previous function, but rather than writing syntax to include files, insert their contents directly.

#+BEGIN_SRC emacs-lisp
(defun zd-org-search-insert (zdSrch)
"Inserts at point all the content of the files with ZDSRCH. When looking for zetteldeft tags, include the # manually in the search."
 (interactive (list (read-string "Search term: ")))
 (dolist (zdFile (zd-get-file-list zdSrch))
   (zd-org-insert-file zdFile)))
#+END_SRC

*** Helper functions
**** =zd-get-file-list= returns file list on search

Get a list of the files with given search string.

To *fix*: sorting of results.

The code searches for the given string and returns =deft-current-files=.

#+BEGIN_SRC emacs-lisp
(defun zd-get-file-list (srch)
"Returns a list of files with the search item SRCH."
  (let ((deft-current-sort-method 'title))
   (deft-filter srch t)
   deft-current-files))
#+END_SRC

**** =zd-lift-file-title= returns file title from path

Returns only the file title from a file, removing path, extension, and link ID.

#+BEGIN_SRC emacs-lisp
(defun zd-lift-file-title (zdFile)
  "Returns the title of a zetteldeft note.
ZDFILE should be a full path to a note."
 (let ((baseName (file-name-base zdFile)))
   (replace-regexp-in-string
    "[0-9]\\{2,\\}-[0-9-]+[[:space:]]"
    "" baseName)))
#+END_SRC

**** =zd-insert-file-contents= returns the contents of a file

Returns the contents of a file.

#+BEGIN_SRC emacs-lisp
(defun zd-file-contents (zdFile &optional removeLines)
  "Inserts file contents of a zetteldeft note.
ZDFILE should be a full path to a note.

Optional: leave out first REMOVELINES lines."
  (with-temp-buffer
    (insert-file-contents zdFile)
    (when removeLines
      (kill-whole-line removeLines))
    (buffer-string)))
#+END_SRC

**** =zd-org-include-file= includes a file in =org= format

Inserts the title as a new header, with the =#+INCLUDE= line below.
Includes only from the second line onward, so that any =#+TITLE= lines are omitted.

#+BEGIN_SRC emacs-lisp
(defun zd-org-include-file (zdFile)
"Insert code to include org-file zdFile."
 (insert
   ;; Insert org-mode title
   "* " (zd-lift-file-title zdFile) "\n"
   ;; Insert #+INCLUDE: "file.org" :lines 2-
   "#+INCLUDE: \"" zdFile "\" :lines \"2-\"\n\n"))
#+END_SRC

**** =zd-org-insert-file= inserts a files content

For a file, insert its title and contents (without first 3 lines).

Even better would be: without any of the lines starting with =#= at the beginning of the file.

#+BEGIN_SRC emacs-lisp
(defun zd-org-insert-file (zdFile)
"Insert title and contents of ZDFILE."
  (insert
    ;; Insert org-mode title
    "\n* " (zd-lift-file-title zdFile) "\n\n"
    ;; Insert file contents (without the first 3 lines)
    (zd-file-contents zdFile 3)))
#+END_SRC

** Aesthetics
*** Highlighting zetteldeft links

To highlight zetteldeft links, let's add a =font-lock= keyword to =org-mode=.

Currently, the regexp to find links is hardcoded.

Highlighting not working in comments.

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode '(
  ("§[0-9]\\{2,\\}-[0-9-]+" . font-lock-warning-face)))
#+END_SRC

** Package provided

That's all folks!

#+BEGIN_SRC emacs-lisp
(provide 'zetteldeft)
;;; zetteldeft.el ends here
#+END_SRC

* Suggested setup

The following assumes =deft= is loaded manually in your dotfile, it merely configures the package.

None of these code blocks are tangled into the =.el= file, they are here merely as a guide.

** Suggested =zeteldeft= keybindings
*** Keybindings with =general=

To call =zetteldeft= functions from anywhere behind a leader key such as =SPC=, I recommend =general.el= with the following setup.

#+BEGIN_SRC emacs-lisp :tangle no
(general-define-key
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
  :states '(normal visual motion emacs)
  :keymaps 'override
  "d"  '(nil :wk "deft")
  "dd" '(deft :wk "deft")
  "dD" '(zd-deft-new-search :wk "new search")
  "dR" '(deft-refresh :wk "refresh")
  "ds" '(zd-search-at-point :wk "search at point")
  "dc" '(zd-search-current-id :wk "search current id")
  "df" '(zd-avy-file-search :wk "avy file search")
  "dF" '(zd-avy-file-search-other-window :wk "avy file other window")
  "dl" '(zd-avy-link-search :wk "avy link search")
  "dt" '(zd-avy-tag-search :wk "avy tag search")
  "dT" '(zd-tag-buffer :wk "tag list")
  "di" '(zd-find-file-id-insert :wk "insert id")
  "dI" '(zd-find-file-full-title-insert :wk "insert full title")
  "do" '(zd-find-file :wk "find file")
  "dn" '(zd-new-file :wk "new file")
  "dN" '(zd-new-file-and-link :wk "new file & link")
  "dr" '(zd-file-rename :wk "rename"))
#+END_SRC

*** Spacemacs keybindings

Suggested keybindings for =spacemacs=.

These can be called from anywhere behind =SPC d=.

#+BEGIN_SRC emacs-lisp :tangle no
;; Prefix
(spacemacs/declare-prefix "d" "deft")
;; Launch deft
(spacemacs/set-leader-keys "dd" 'deft)
(spacemacs/set-leader-keys "dD" 'zd-deft-new-search)
;; SEARCH
 ; Search thing at point
   (spacemacs/set-leader-keys "ds" 'zd-search-at-point)
 ; Search current file id
   (spacemacs/set-leader-keys "dc" 'zd-search-current-id)
 ; Jump & search with avy 
 ;  search link as filename
    (spacemacs/set-leader-keys "df" 'zd-avy-file-search)
    (spacemacs/set-leader-keys "dF" 'zd-avy-file-search-other-window)
 ;  search link as contents
    (spacemacs/set-leader-keys "dl" 'zd-avy-link-search)
 ;  search tag as contents
    (spacemacs/set-leader-keys "dt" 'zd-avy-tag-search)
 ;  find all tags
    (spacemacs/set-leader-keys "dT" 'zd-tag-buffer)
;; LINKS
 ; Insert link from filename
   (spacemacs/set-leader-keys "di" 'zd-find-file-id-insert)
 ; Insert link with full filename
   (spacemacs/set-leader-keys "dI" 'zd-find-file-full-title-insert)
;; FILES
 ; Open file
   (spacemacs/set-leader-keys "do" 'zd-find-file)
 ; Create new file
   (spacemacs/set-leader-keys "dn" 'zd-new-file)
   (spacemacs/set-leader-keys "dN" 'zd-new-file-and-link)
 ; Rename file
   (spacemacs/set-leader-keys "dr" 'zd-file-rename)
;; UTILITIES
(spacemacs/set-leader-keys "dR" 'deft-refresh)
#+END_SRC

** Suggested =deft= setup
*** Notes & extensions

Note extensions are =md=, =txt= and =org=.
First of this list is the default for new notes.

#+BEGIN_SRC emacs-lisp :tangle no
(setq deft-extensions '("org" "md" "txt"))
#+END_SRC

*** Set =deft-directory=

Search the deft directory recursively, to include subdirectories.

#+BEGIN_SRC emacs-lisp :tangle no
(setq deft-directory (concat org-directory "/notes/zetteldeft"))
(setq deft-recursive t)
#+END_SRC

*** Additional =deft= functions

Some personal additions.

A small function to open a file in the other window and shifting focus to it.
That final part is what the =t= argument does.

#+BEGIN_SRC emacs-lisp :tangle no
(defun efls/deft-open-other ()
 (interactive)
 (deft-open-file-other-window t))
#+END_SRC

Let's add another function, to simply preview in the other window, i.e. not switch focus to it.

#+BEGIN_SRC emacs-lisp :tangle no
(defun efls/deft-open-preview ()
 (interactive)
 (deft-open-file-other-window))
#+END_SRC


To select results from the item list without leaving the =insert= state, I add the following keys.

#+BEGIN_SRC emacs-lisp :tangle no
(with-eval-after-load 'deft
  (define-key deft-mode-map
    (kbd "<tab>") 'efls/deft-open-preview)
  (define-key deft-mode-map
    (kbd "<s-return>") 'efls/deft-open-other)
  (define-key deft-mode-map
    (kbd "s-j") 'evil-next-line)
  (define-key deft-mode-map (kbd "s-k") 'evil-previous-line))
#+END_SRC

*** Ignore more =org-mode= metadata

I tend to write =org-mode= titles with =#+title:= (i.e., uncapitalized). Also other =org-mode= code at the beginning is written in lower case.

In order to filter these from the deft summary, let's alter the regular expression:

#+BEGIN_SRC emacs-lisp :tangle no
(setq deft-strip-summary-regexp
 (concat "\\("
         "[\n\t]" ;; blank
         "\\|^#\\+[a-zA-Z_]+:.*$" ;;org-mode metadata
         "\\)"))
#+END_SRC

Its original value was =\\([\n ]\\|^#\\+[[:upper:]_]+:.*$\\)=.

* Brainstorm

Some ideas for the future.

** Saved searches

Create a list of saved searches, somewhere easily accessible.

** Generate list of tags

Auto-generate a list of tags.

Might exceed my elisp-fu.

** HTML export

Export HTML pages with clickeable links between notes.

** Markdown export

Export markdown through =pandoc=.

** Templates

A system for note templates.

** Minor mode

Create a minor mode on top of org-mode with some niceties:
 - higlight links & tags
 - clickeable links
